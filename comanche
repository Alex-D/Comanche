#!/usr/bin/perl

use Socket;


# Quitte s'il manque le paramètre
die("Option nécessaire parmis : start, stop, status, reload\n") if ($#ARGV < 0);


# Récupère la commande
$commande = $ARGV[0]; # start, stop, status


# Configuration
$pidfile = ".pid";
chargerconfig();


# Compteurs
$reqrecues      = 0;
$reqtraitees    = 0;


# Liste des pid des fils
@fils = ();



if ($commande eq "start") {
    die("Une autre instance de Commanche est déjà en cours...\n") if(-f $pidfile);

    # Crée un fork et tue le père pour rendre la main
    $pid = fork;
    if ($pid != 0) {
        # Stock le pid du fils
        open(PID, ">$pidfile");
        print PID $pid;
        close(PID);

        # Tue le père
        exit 0;
    }

    ajouterlog("start");


    # Traitement des signaux
    #   USR1 => status
    $SIG{USR1} = \&status;
    #   QUIT => stop
    $SIG{QUIT} = \&stop;

    
    # Lancement de la socket
    socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
    setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);

    $port = $config{"global"}{"port"};
    $addr = sockaddr_in($port, INADDR_ANY) || do { unlink($pidfile); die("sockaddr_in\n"); };
    bind(SERVEUR, $addr) || do { unlink($pidfile); die("Le port $port est déjà utilisé\n"); };
    listen(SERVEUR, SOMAXCONN) || do { unlink($pidfile); die("listen error\n"); };

    printf "Serveur lancé sur le port $port\n";

    $started = 1;

    while ($started) {
        $client = accept(CLIENT, SERVEUR) or do { last if $started eq 0; next if $!{EINTR}; die("Accept impossible : $!\n"); };

        $reqrecues += 1;

        autoflush CLIENT 1;


        if ($#fils >= $config{"global"}{"clients"}) {
            $reponse  = "<html><body>" .
                        "<h1>503 Service Unavailable</h1>" .
                        "<h2>Trop de connexions simultanées, réessayez plus tard</h2>" .
                        "</body></html>";

            printf CLIENT   "HTTP/1.1 503 Service Unavailable\r\n" .
                            "Content-Type: text/html; charset=utf-8\r\n" .
                            "Content-Length: " . length($reponse) . "\r\n\r\n" .
                            $reponse;
        } else {
            $pid = fork;
            
            if ($pid == 0) {
                # Traitement de la requête
                $req = <CLIENT>;
                while (<CLIENT> =~ /^\r?\n/) {}

                $req =~ /(?-i)GET(?i)\s(\/(?:.*))\sHTTP\/1\.1/ || repondre400();
                $req = $1;

                # TODO: Récupérer l'IP
                $ip = "123.123.123.123";

                # Si le chemin existe
                # TODO: Recherche de la page correspondant à la requête
                if ($req =~ /nematchpas/) {
                    $fichier = "UN_FICHIER";

                    repondre404() unless(-f $fichier);

                    $reponse = lirefichier($fichier);

                    # On envoie la réponse
                    printf CLIENT   "HTTP/1.1 200 OK\r\n" .
                                    "Content-Type: text/html\r\n" .
                                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                                    $reponse;

                	ajouterlog("get-X", $ip, $req, "chemin", 200);

                    close CLIENT;

                    exit 0;
                }

                # Si aucune réponse n'a été construite
                repondre404();
            }

            push(@fils, $pid);

            $reqtraitees += 1;
        }

        close CLIENT;
    }

    close CLIENT;
    close SERVEUR;
    
} elsif ($commande eq "status") {
    # status
    kill USR1, pidserv() || die("Le serveur n'est pas lancé\n");
} elsif ($commande eq "stop") {
    # stop
    kill QUIT, pidserv() || die("Le serveur n'est pas lancé\n");

    ajouterlog("stop");

    unlink($pidfile);
} elsif ($commande eq "reload") {
    # reload
    pidserv() || die("Le serveur n'est pas lancé\n");

    chargerconfig();
} else {
    die("Paramètre non pris en charge. Paramètres autorisés : start, stop, status, reload\n");
}



# TODO: Retourne la route associée à la requête
sub recupererroute {

}


# TODO: Donne le chemin réel du fichier demandé par la requête
sub recupererchemin {

}


# Réponse en cas de requête invalide
sub repondre400
{
    $reponse =  "<html><body>" .
                "<h1>400 Bad Request</h1>" .
                "<h2>Requête invalide</h2>" .
                "</body></html>";

    printf CLIENT   "HTTP/1.1 400 Bad Request\r\n" .
                    "Content-Type: text/html; charset=utf-8\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    close CLIENT;

    exit 0;
}


# Renvoie une erreur 404
sub repondre404
{
	# Par défaut, la réponse sera la page définie dans la configuration
    $reponse = lirefichier($config{"global"}{"default"});

    # On envoie la réponse
    printf CLIENT   "HTTP/1.1 404 Not Found\r\n" .
                    "Content-Type: text/html\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    # Ajout au log de la requête effectuée
    ajouterlog("GET", $ip, $req, $config{"global"}{"default"}, 404);

    close CLIENT;

    exit 0;
}


# Charge la configuration
sub chargerconfig
{
    # Vide la configuration
    undef %config;

    # Charge la configuration depuis le fichier comanche.conf
    open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
    while(<CONFIG>) {
        if(/^set\s+(.+)\s+(.+)/){
            $cle    = $1;
            $valeur = $2;

            if($cle =~ /port/){         # Validation du port TCP
                die("[Erreur configuration] Port invalide\n") unless($valeur =~ /[\d+]/ && $valeur >= 1 && $valeur <= 65535);
            } elsif($cle =~ /clients/){ # Validation du nombre de clients
                die("[Erreur configuration] Nombre de clients invalide\n") unless($valeur =~ /\d+/);
            } elsif($cle =~ /default/){ # Validation du fichier par défaut
                die("[Erreur configuration] Fichier default inaccessible\n") unless(-f $valeur);
            }

            $config{"global"}{$cle} = $valeur;
        } elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
            $config{"routes"}{$1} = $2;
        } elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
            $config{"exec"}{$1} = $2;
        } 
    }
    close(CONFIG);
}


# Récupère le pid du fils
sub pidserv
{
    open(FILS, "$pidfile");
    $pid = <FILS>;
    close(FILS);

    return $pid;
}


# Arrête le serveur
sub stop
{
    $started = 0;

    while (wait != -1) {}
}


# Affiche le status du serveur
sub status
{
    local $, = ", ";
    print "PID du processus principal : $$\n" .
          "Nombre de requêtes :\n" .
          "\treçues : $reqrecues\n" .
          "\ttraitées : $reqtraitees\n" .
          "Nombre d'ouvriers actifs : $#fils\n";
    print @fils;
}


# Retourne le contenu d'un fichier
sub lirefichier
{
    my $contenu;

    open(FICHIER, $_[0]) || return "";
    while (<FICHIER>) {
        $contenu .= $_;
    }
    close(FICHIER);

    return $contenu;
}


# Ajoute une ligne au log de la forme
# <date>;<type>;<machine>;<requête>;<projection>;<réponse>;
sub ajouterlog
{
    open(LOG, ">>".$config{"global"}{"logfile"});

    if($_[0] eq "start" || $_[0] eq "stop"){
        @line = (date(), $_[0], "local", $conf{"port"}, "", "", "");
    } else {
        @line = (date(), @_);
    }

    local $, = ";";
    print LOG @line,"\n";
    
    close(LOG);
}


# Formate la date de façon lisible
sub date
{
    ($s, $min, $h, $j, $m, $a) = localtime(time);

    $s      = ($s > 10)     ? $s    : "0$s";
    $min    = ($min > 10)   ? $min  : "0$min";
    $h      = ($h > 10)     ? $h    : "0$h";

    return "$h:$min:$s $j/$m/" . ($a+1900);
}