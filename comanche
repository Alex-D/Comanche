#!/usr/bin/perl

use Socket;


# Quitte s'il manque le paramètre
die("Option nécessaire parmis : start, stop, status, reload\n") if($#ARGV < 0);


# Récupère la commande
$commande = $ARGV[0]; # start, stop, status


# Configuration
$pidfile = ".pid";
chargerconfig();


# Compteurs
$reqrecues      = 0;
$reqtraitees    = 0;


# Liste des pid des fils
@fils = ();



if ($commande eq "start") {
    die("Une autre instance de Commanche est déjà en cours...\n") if(-f $pidfile);

    # Crée un fork et tue le père pour rendre la main
    $pid = fork;
    if ($pid != 0) {
        # Stock le pid du fils
        open(PID, ">$pidfile");
        print PID $pid;
        close(PID);

        # Tue le père
        exit 0;
    }

    addlog("start");


    # Traitement des signaux
    #   USR1 => status
    $SIG{USR1} = \&status;
    #   QUIT => stop
    $SIG{QUIT} = \&stop;

    
    # Lancement de la socket
    socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
    setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);

    $port = $config{"global"}{"port"};
    $addr = sockaddr_in($port, INADDR_ANY) || do { die("sockaddr_in"); unlink($pidfile); };
    bind(SERVEUR, $addr) || do { die("Le port $port est déjà utilisé\n"); unlink($pidfile); };
    listen(SERVEUR, SOMAXCONN) || do { die("listen error"); unlink($pidfile); };

    printf "Serveur lancé sur le port $port\n";

    $started = 1;

    while ($started) {
        $client = accept(CLIENT, SERVEUR) or do { last if $started eq 0; next if $!{EINTR}; die("Accept impossible : $!\n"); };

        $reqrecues += 1;

        autoflush CLIENT 1;


        if ($#fils >= $config{"global"}{"clients"}) {
            $reponse  = "<html><body>" .
                        "<h1>503 Service Unavailable</h1>" .
                        "<h2>Trop de connexions simultannées, réessayez plus tard</h2>" .
                        "</body></html>";

            printf CLIENT   "HTTP/1.1 503 Service Unavailable\r\n" .
                            "Content-Type: text/html; charset=utf-8\r\n" .
                            "Content-Length: " . length($reponse) . "\r\n\r\n" .
                            $reponse;
        } else {
            $pid = fork;
            
            if ($pid == 0){
                # Traitement de la requête
                $req = <CLIENT>;
                while (<CLIENT> =~ /^\r?\n/) {}

                $req =~ /(?-i)GET(?i)\s(\/(?:.*))\sHTTP\/1\.1/ || badrequest;
                $req = $1;

                # Si le chemin existe
                if ($req =~ /nematchpas/) {
                    # TODO: Recherche de la page correspondant à la requête
                    # $reponse = readfile(LE_FICHIER);

                    # On envoie la réponse
                    printf CLIENT   "HTTP/1.1 200 OK\r\n" .
                                    "Content-Type: text/html\r\n" .
                                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                                    $reponse;
                } 

                # Si aucune réponse n'a été construite
                unless (length($reponse)) {
                    # Par défaut, la réponse sera la page définie dans la configuration
                    $reponse = readfile($config{"global"}{"default"});

                    # On envoie la réponse
                    printf CLIENT   "HTTP/1.1 200 OK\r\n" .
                                    "Content-Type: text/html\r\n" .
                                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                                    $reponse;
                }

                close CLIENT or die("$!");;


                # Ajout au log de la requête effectuée
                addlog("GET", "IP", $req, "", "");

                # addlog("get-X", IP, <requête>, <projection = chemin>, <code HTTP>);


                exit 0;
            }

            push(@fils, $pid);

            $reqtraitees += 1;
        }

        close CLIENT or die("$!");;
    }

    close CLIENT or die("$!");;
    close SERVEUR or die("$!");;
    
} elsif ($commande eq "status") {
    # status
    kill USR1, pidserv() || die("Le serveur n'est pas lancé\n");
} elsif ($commande eq "stop") {
    # stop
    kill QUIT, pidserv() || die("Le serveur n'est pas lancé\n");

    addlog("stop");

    unlink($pidfile);
} elsif ($commande eq "reload") {
    # reload
    pidserv() || die("Le serveur n'est pas lancé\n");

    chargerconfig();
} else {
    die("Paramètre non pris en charge. Paramètres autorisés : start, stop, status, reload\n");
}




# Réponse en cas de requête invalide
sub badrequest {
    $reponse  = "<html><body>" .
                "<h1>400 Bad Request</h1>" .
                "<h2>Requête invalide</h2>" .
                "</body></html>";

    printf CLIENT   "HTTP/1.1 400 Bad Request\r\n" .
                    "Content-Type: text/html; charset=utf-8\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    close CLIENT;

    exit 0;
}


# Charge la configuration
sub chargerconfig {
    # Vide la configuration
    undef %config;

    # Charge la configuration depuis le fichier comanche.conf
    open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
    while(<CONFIG>) {
        if(/^set\s+(.+)\s+(.+)/){
            $cle    = $1;
            $valeur = $2;

            if($cle =~ /port/){         # Validation du port TCP
                die("[Erreur configuration] Port invalide\n") unless($valeur =~ /[\d+]/ && $valeur >= 1 && $valeur <= 65535);
            } elsif($cle =~ /clients/){ # Validation du nombre de clients
                die("[Erreur configuration] Nombre de clients invalide\n") unless($valeur =~ /\d+/);
            } elsif($cle =~ /default/){ # Validation du fichier par défaut
                die("[Erreur configuration] Fichier default inaccessible\n") unless(-f $valeur);
            }

            $config{"global"}{$cle} = $valeur;
        } elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
            $config{"routes"}{$1} = $2;
        } elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
            $config{"exec"}{$1} = $2;
        } 
    }
    close(CONFIG);
}


# Récupère le pid du fils
sub pidserv {
    open(FILS, "$pidfile");
    $pid = <FILS>;
    close(FILS);

    return $pid;
}


# Arrête le serveur
sub stop {
    $started = 0;

    while(wait != -1){}
}


# Affiche le status du serveur
sub status {
    local $, = ", ";
    print "PID du processus principal : $$\n";
    print "Nombre de requêtes :\n";
    print "\treçues : $reqrecues\n";
    print "\ttraitées : $reqtraitees\n";
    print "Nombre d'ouvriers actifs : $#fils\n";
    print @fils;
}


# Retourne le contenu d'un fichier
sub readfile {
    my $contenu;

    open(DEFAULT, $_[0]);
    while(<DEFAULT>){
        $contenu .= $_;
    }
    close(DEFAULT);

    return $contenu;
}


# Ajoute une ligne au log de la forme
# <date>;<type>;<machine>;<requête>;<projection>;<réponse>;
sub addlog {
    open(LOG, ">>".$config{"global"}{"logfile"});

    if($_[0] eq "start" || $_[0] eq "stop"){
        @line = (date(), $_[0], "local", $conf{"port"}, "", "", "");
    } else {
        @line = (date(), @_);
    }

    local $, = ";";
    print LOG @line,"\n";
    
    close(LOG);
}


# Formate la date de façon lisible
sub date {
    ($s, $min, $h, $j, $m, $a) = localtime(time);

    $s      = ($s > 10)     ? $s    : "0$s";
    $min    = ($min > 10)   ? $min  : "0$min";
    $h      = ($h > 10)     ? $h    : "0$h";

    return "$h:$min:$s $j/$m/" . ($a+1900);
}