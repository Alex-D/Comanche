#!/usr/bin/perl

use Socket;
use File::MimeInfo;


# Quitte s'il manque le paramètre
die("Option nécessaire parmis : start, stop, status, reload\n") if ($#ARGV < 0);


# Récupère la commande
$commande = $ARGV[0]; # start, stop, status, reload


# Configuration
$pidfile = ".pid";
chargerconfig();


# Compteurs
$reqrecues      = 0;
$reqtraitees    = 0;


# Liste des pid des fils
@fils = ();



if ($commande eq "start") {
    die("Une autre instance de Commanche est déjà en cours...\n") if(-f $pidfile);

    # Crée un fork et tue le père pour rendre la main
    $pid = fork;
    if ($pid != 0) {
        # Stock le pid du fils
        open(PID, ">$pidfile");
        print PID $pid;
        close(PID);

        # Tue le père
        exit 0;
    }

    ajouterlog("start");


    # Traitement des signaux
    #   USR1 => status
    $SIG{USR1} = \&status;
    #   QUIT => stop
    $SIG{QUIT} = \&stop;
    #   CHLD => retirerfils
    $SIG{CHLD} = \&retirerfils;

    
    # Lancement de la socket
    socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
    setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);

    $port = $config{"global"}{"port"};
    $addr = sockaddr_in($port, INADDR_ANY) || do { unlink($pidfile); die("sockaddr_in\n"); };
    bind(SERVEUR, $addr) || do { unlink($pidfile); die("Le port $port est déjà utilisé\n"); };
    listen(SERVEUR, SOMAXCONN) || do { unlink($pidfile); die("listen error\n"); };

    printf "Serveur lancé sur le port $port\n";

    $started = 1;

    while (accept(CLIENT, SERVEUR) or do { last if $started eq 0; next if $!{EINTR}; die("Accept impossible : $!\n"); }) {
        $reqrecues += 1;

        autoflush CLIENT 1;


        if ($#fils >= $config{"global"}{"clients"}) {
            $reponse  = "<html><body>" .
                        "<h1>503 Service Unavailable</h1>" .
                        "<h2>Trop de connexions simultanées, réessayez plus tard</h2>" .
                        "</body></html>";

            printf CLIENT   "HTTP/1.1 503 Service Unavailable\r\n" .
                            "Content-Type: text/html; charset=utf-8\r\n" .
                            "Content-Length: " . length($reponse) . "\r\n\r\n" .
                            $reponse;
        } else {
            $pid = fork;
            
            if ($pid == 0) {
                # Traitement de la requête
                $req = <CLIENT>;
                while (<CLIENT> =~ /^\r?\n/) {}

                $req =~ /(?-i)GET(?i)\s(\/(?:.*))\sHTTP\/1\.1/ || repondre400();
                $req = $1;


                # Récupère l'adresse IP
                $peer           = getpeername(CLIENT);
                ($port, $iaddr) = sockaddr_in($peer);
                $ip             = inet_ntoa($iaddr);


                @fichier = recupererchemin($req);
                $exec    = $fichier[0];
                $fichier = $fichier[1];

                repondre404() unless(-f $fichier);

                $reponse = lirefichier($fichier);

                # TODO : savoir si c'est un executable
                if ($exec) {
                    $reponse = executer($fichier);
                    $mimetype = "text/html";
                } else {
                    $mimetype = mimetype($fichier);
                }
                

                repondre404 unless($mimetype eq "text/html" || $mimetype eq "image/jpeg" || $mimetype eq "image/pjpeg");

                # On envoie la réponse
                printf CLIENT   "HTTP/1.1 200 OK\r\n" .
                                "Content-Type: $mimetype\r\n" .
                                "Content-Length: " . length($reponse) . "\r\n\r\n" .
                                $reponse;

            	ajouterlog("get-X", $ip, $req, "chemin", 200);

                close CLIENT;

                exit 0;
            }

            push(@fils, $pid);

            $reqtraitees += 1;
        }

        close CLIENT;
    }

    close CLIENT;
    close SERVEUR;
    
} elsif ($commande eq "status") {
    # status
    kill USR1, pidserv() || die("Le serveur n'est pas lancé\n");
} elsif ($commande eq "stop") {
    # stop
    kill QUIT, pidserv() || die("Le serveur n'est pas lancé\n");

    ajouterlog("stop");

    unlink($pidfile);
} elsif ($commande eq "reload") {
    # reload
    pidserv() || die("Le serveur n'est pas lancé\n");

    chargerconfig();
} else {
    die("Paramètre non pris en charge. Paramètres autorisés : start, stop, status, reload\n");
}



# Retourne la route associée à la requête
sub recupererroute
{
    $req = $_[0];

    for $route (@{$config{"rewriterules"}}) {
        if ($req =~ /$route/) {
            if (exists $config{"routes"}{$route}) {
                return ("route", $route, $config{"routes"}{$route});
            } elsif (exists $config{"exec"}{$route}) {
                return ("exec", $route, $config{"exec"}{$route});
            }
        }
    }

    # Si la route ne correspond à rien, on retourne une 404
    repondre404();
}


# Donne le chemin réel du fichier demandé par la requête
sub recupererchemin
{
    my @route = recupererroute($_[0]);
    my $p1 = qr/$route[1]/;

    $_ = $_[0];

    # TODO : faire proprement la transformation avec s/// et l'interprétation du \1
    my @matches = m/$p1/;
    my $p2 = $route[2];

    for (@matches) {
	   $m = $matches[$i++];
	   $p2 =~ s{\\$i}{$m};
    }

    m/$p2/;

    return ($route[0], $p2);
}


# TODO : Executer CGI
sub executer
{
    return $_[0];
}


# Réponse en cas de requête invalide
sub repondre400
{
    $reponse =  "<html><body>" .
                "<h1>400 Bad Request</h1>" .
                "<h2>Requête invalide</h2>" .
                "</body></html>";

    printf CLIENT   "HTTP/1.1 400 Bad Request\r\n" .
                    "Content-Type: text/html; charset=utf-8\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    close CLIENT;

    exit 0;
}


# Renvoie une erreur 404
sub repondre404
{
	# Par défaut, la réponse sera la page définie dans la configuration
    $reponse = lirefichier($config{"global"}{"default"});

    # On envoie la réponse
    printf CLIENT   "HTTP/1.1 404 Not Found\r\n" .
                    "Content-Type: text/html\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    # Ajout au log de la requête effectuée
    ajouterlog("GET", $ip, $req, $config{"global"}{"default"}, 404);

    close CLIENT;

    exit 0;
}


# Charge la configuration
sub chargerconfig
{
    # Vide la configuration
    undef %config;

    # Charge la configuration depuis le fichier comanche.conf
    open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
    while(<CONFIG>) {
        if(/^set\s+(.+)\s+(.+)/){
            $cle    = $1;
            $valeur = $2;

            if($cle =~ /port/){         # Validation du port TCP
                die("[Erreur configuration] Port invalide\n") unless($valeur =~ /[\d+]/ && $valeur >= 1 && $valeur <= 65535);
            } elsif($cle =~ /clients/){ # Validation du nombre de clients
                die("[Erreur configuration] Nombre de clients invalide\n") unless($valeur =~ /\d+/);
            } elsif($cle =~ /default/){ # Validation du fichier par défaut
                die("[Erreur configuration] Fichier default inaccessible\n") unless(-f $valeur);
            }

            $config{"global"}{$cle} = $valeur;
        } elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
            $config{"routes"}{$1} = $2;
            push(@{$config{"rewriterules"}}, $1);
        } elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
            $config{"exec"}{$1} = $2;
            push(@{$config{"rewriterules"}}, $1);
        } 
    }
    close(CONFIG);
}


# Récupère le pid du fils
sub pidserv
{
    open(FILS, "$pidfile");
    $pid = <FILS>;
    close(FILS);

    return $pid;
}


# Arrête le serveur
sub stop
{
    $started = 0;

    while (wait != -1) {}
}


# Affiche le status du serveur
sub status
{
    local $, = ", ";
    print "PID du processus principal : $$\n" .
          "Nombre de requêtes :\n" .
          "\treçues : $reqrecues\n" .
          "\ttraitées : $reqtraitees\n" .
          "Nombre d'ouvriers actifs : ". (($#fils > 0) ? $#fils : "aucun") ."\n";
    print @fils;

    close CLIENT;
}


# Retire le fils mort de la liste des fils
sub retirerfils
{
    $pid = wait();
    @fils = grep { $_ != $pid } @fils;
}


# Retourne le contenu d'un fichier
sub lirefichier
{
    my $contenu;

    open(FICHIER, $_[0]) || return "";
    while (<FICHIER>) {
        $contenu .= $_;
    }
    close(FICHIER);

    return $contenu;
}


# Ajoute une ligne au log de la forme
# <date>;<type>;<machine>;<requête>;<projection>;<réponse>;
sub ajouterlog
{
    open(LOG, ">>".$config{"global"}{"logfile"});

    if($_[0] eq "start" || $_[0] eq "stop"){
        @line = (date(), $_[0], "local", $conf{"port"}, "", "", "");
    } else {
        @line = (date(), @_);
    }

    local $, = ";";
    print LOG @line,"\n";
    
    close(LOG);
}


# Formate la date de façon lisible
sub date
{
    my ($s, $min, $h, $j, $m, $a) = localtime(time);
    my @jours = ("Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim");
    my @mois = ("Jan", "Fev", "Mar", "Avr", "Mai", "Jun", "Jul", "Aou", "Sep", "Oct", "Nov", "Dec");

    $s      = ($s > 10)     ? $s    : "0$s";
    $min    = ($min > 10)   ? $min  : "0$min";
    $h      = ($h > 10)     ? $h    : "0$h";
    $j      = ($j > 10)     ? $j    : "0$j";

    return "$jours[$j] $mois[$m] $h:$min:$s " . ($a+1900);
}