#!/usr/bin/perl

use Socket;


# Quitte s'il manque le paramètre
die("Option nécessaire parmis : start, stop, status, reload\n") if($#ARGV < 0);


# Récupère la commande
$commande = $ARGV[0]; # start, stop, status


# Lecture de la configuration
chargerconfig();
$pidfile = ".pid";


# Liste des pid des fils
@fils = ();



if ($commande eq "start") {
	# Crée un fork et tue le père pour rendre la main
	$pid = fork;
	if ($pid != 0) {
		# Stock le pid du fils
		open(PID, ">$pidfile");
		print PID $pid;
		close(PID);

		addlog("start");

		# Tue le père
		exit 0;
	}


	# Traitement des signaux
	#   KILL => stop
	$SIG{KILL} = \&stop;
	#   USR1 => status
	$SIG{USR1} = \&status;

	
	# Lancement de la socket
	socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);

	$addr = sockaddr_in($config{"global"}{"port"}, INADDR_ANY) || die("sockaddr_in");
	bind(SERVEUR, $addr) || die("bind error");
	listen(SERVEUR, SOMAXCONN) || die("listen error");

	while (accept(CLIENT, SERVEUR)) {
		$reqrecues += 1;

		select CLIENT;
		autoflush 1;

		if ($#fils >= $config{"global"}{"clients"}) {
			printf "HTTP/1.1 503 Service Unavailable\r\n";
			printf "Content-Type: text/html\r\n";
			printf "Content-Length: 111\r\n\r\n"; # TODO: compter caractères

			printf "<html><body>";
			printf "<h1>503 Service Unavailable</h1>";
			printf "<h2>Trop de connexions simultannées, réessayez plus tard</h2>";
			printf "HTTP 1.1 requests must include the Host: header.";
			printf "</body></html>";

			close CLIENT;
		} else {
			$pid = fork;
			
			if ($pid == 0){

				# TODO: traiter la requête

				# addlog("get-X", IP, <requête>, <projection = chemin>, <code HTTP>);

				close CLIENT;
				exit 0;
			}

			$reqtraitees += 1;
		}
	}

	close SERVEUR;
	
} elsif ($commande eq "status") {
	# status
	kill USR1, pidserv() || die("Le serveur n'est pas lancé\n");
} elsif ($commande eq "stop") {
	# stop
	kill KILL, pidserv() || die("Le serveur n'est pas lancé\n");

	unlink($pidfile);
} elsif ($commande eq "reload") {
	chargerconfig();
} else {
	die("Paramètre non pris en charge. Paramètres autorisés : start, stop, status, reload\n");
}




# Charge la configuration
sub chargerconfig {
	# Vide la configuration
	undef %config;

	# Charge la configuration depuis le fichier comanche.conf
	open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
	while(<CONFIG>) {
		if(/^set\s+(.+)\s+(.+)/){
			$cle 	= $1;
			$valeur = $2;

			if($cle =~ /port/){			# Validation du port TCP
				die("[Erreur configuration] Port invalide\n") unless($valeur =~ /[\d+]/ && $valeur >= 1 && $valeur <= 65535);
			} elsif($cle =~ /clients/){	# Validation du nombre de clients
				die("[Erreur configuration] Nombre de clients invalide\n") unless($valeur =~ /\d+/);
			} elsif($cle =~ /default/){ # Validation du fichier par défaut
				die("[Erreur configuration] Fichier default inaccessible\n") unless(-f $valeur);
			} elsif($cle =~ /index/){	# Validation du fichier d'index
				die("[Erreur configuration] Fichier index inaccessible\n") unless(-f $valeur);
			}

			$config{"global"}{$cle} = $valeur;
		} elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
			$config{"routes"}{$1} = $2;
		} elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
			$config{"exec"}{$1} = $2;
		} 
	}
	close(CONFIG);
}


# Récupère le pid du fils
sub pidserv {
	open(FILS, ".pid");
	$pid = <FILS>;
	close(FILS);

	return $pid;
}


# Arrête le serveur
sub stop {
	while(wait != -1){}
	addlog("stop");
	exit 0;
}


# Affiche le status du serveur
sub status {
	local $, = ", ";
	print "PID du processus principal : $$\n";
	print "Nombre de requêtes :\n";
	print "\treçues : $reqrecues\n";
	print "\ttraitées : $reqtraitees\n";
	print "Nombre d'ouvriers actifs : $#fils\n";
	print @fils;
}


# Ajoute une ligne au log de la forme
# <date>;<type>;<machine>;<requête>;<projection>;<réponse>;
sub addlog {
	open(LOG, ">>$logfile");

	if($_[0] == "start" || $_[0] == "stop"){
		@line = (localtime(time), $_[0], "local", $conf{"port"},,,);
	} else {
		@line = (localtime(time), @_);
	}

	local $, = ";";
	print @line;
	
	close(LOG);
}